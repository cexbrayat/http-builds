{"version":3,"file":"client.js","sources":["../../../../../packages/http/client/index.ts","../../../../../packages/http/client/public_api.ts","../../../../../packages/http/client/src/url_params.ts","../../../../../packages/http/client/src/module.ts","../../../../../packages/http/client/src/xhr.ts","../../../../../packages/http/client/src/jsonp.ts","../../../../../packages/http/client/src/interceptor.ts","../../../../../packages/http/client/src/client.ts","../../../../../packages/http/client/src/response.ts","../../../../../packages/http/client/src/request.ts","../../../../../packages/http/client/src/headers.ts","../../../../../packages/http/client/src/backend.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {HttpBackend,HttpHandler,HttpJsonpOptions,HttpMethodOptions,HttpObserve,HttpRequestOptions,zHttpMethodOptionsObserveArrayBufferBody,zHttpMethodOptionsObserveArrayBufferEvents,zHttpMethodOptionsObserveArrayBufferResponse,zHttpMethodOptionsObserveBlobBody,zHttpMethodOptionsObserveBlobEvents,zHttpMethodOptionsObserveBlobResponse,zHttpMethodOptionsObserveEvents,zHttpMethodOptionsObserveResponse,zHttpMethodOptionsObserveTextBody,zHttpMethodOptionsObserveTextEvents,zHttpMethodOptionsObserveTextResponse,zHttpRequestBodyOptions,zHttpRequestOptionsObserveArrayBufferBody,zHttpRequestOptionsObserveArrayBufferEvents,zHttpRequestOptionsObserveArrayBufferResponse,zHttpRequestOptionsObserveBlobBody,zHttpRequestOptionsObserveBlobEvents,zHttpRequestOptionsObserveBlobResponse,zHttpRequestOptionsObserveEvents,zHttpRequestOptionsObserveResponse,zHttpRequestOptionsObserveTextBody,zHttpRequestOptionsObserveTextEvents,zHttpRequestOptionsObserveTextResponse,HttpClient,HttpHeaders,HTTP_INTERCEPTORS,HttpInterceptor,JsonpClientBackend,JsonpInterceptor,JsonpCallbackMap,HttpClientJsonpModule,HttpClientModule,HttpBodyMethod,HttpNoBodyMethod,HttpMethod,HttpRequest,HttpRequestClone,HttpRequestInit,HttpResponseType,HttpSerializedBody,HttpResponseBase,HttpDownloadProgressEvent,HttpErrorResponse,HttpEvent,HttpEventType,HttpHeaderResponse,HttpProgressEvent,HttpResponse,HttpResponseHeaderInit,HttpResponseInit,HttpSentEvent,HttpUserEvent,HttpQueryEncoder,HttpUrlParams,BrowserXhr,HttpXhrBackend,XhrFactory} from './public_api';\n\nexport {interceptingHandler as ɵa,jsonpCallbackMap as ɵb} from './src/module';","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {HttpBackend, HttpHandler} from './src/backend';\nexport {HttpJsonpOptions, HttpMethodOptions, HttpObserve, HttpRequestOptions, zHttpMethodOptionsObserveArrayBufferBody, zHttpMethodOptionsObserveArrayBufferEvents, zHttpMethodOptionsObserveArrayBufferResponse, zHttpMethodOptionsObserveBlobBody, zHttpMethodOptionsObserveBlobEvents, zHttpMethodOptionsObserveBlobResponse, zHttpMethodOptionsObserveEvents, zHttpMethodOptionsObserveResponse, zHttpMethodOptionsObserveTextBody, zHttpMethodOptionsObserveTextEvents, zHttpMethodOptionsObserveTextResponse, zHttpRequestBodyOptions, zHttpRequestOptionsObserveArrayBufferBody, zHttpRequestOptionsObserveArrayBufferEvents, zHttpRequestOptionsObserveArrayBufferResponse, zHttpRequestOptionsObserveBlobBody, zHttpRequestOptionsObserveBlobEvents, zHttpRequestOptionsObserveBlobResponse, zHttpRequestOptionsObserveEvents, zHttpRequestOptionsObserveResponse, zHttpRequestOptionsObserveTextBody, zHttpRequestOptionsObserveTextEvents, zHttpRequestOptionsObserveTextResponse,} from './src/client_types';\nexport {HttpClient} from './src/client';\nexport {HttpHeaders} from './src/headers';\nexport {HTTP_INTERCEPTORS, HttpInterceptor} from './src/interceptor';\nexport {JsonpClientBackend, JsonpInterceptor, JsonpCallbackMap} from './src/jsonp';\nexport {HttpClientJsonpModule, HttpClientModule} from './src/module';\nexport {HttpBodyMethod, HttpNoBodyMethod, HttpMethod, HttpRequest, HttpRequestClone, HttpRequestInit, HttpResponseType, HttpSerializedBody} from './src/request';\nexport {HttpResponseBase, HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpProgressEvent, HttpResponse, HttpResponseHeaderInit, HttpResponseInit, HttpSentEvent, HttpUserEvent} from './src/response';\nexport {HttpQueryEncoder, HttpUrlParams} from './src/url_params';\nexport {BrowserXhr, HttpXhrBackend, XhrFactory} from './src/xhr';\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @param {?=} rawParams\n * @return {?}\n */\nfunction paramParser(rawParams: string = ''): Map<string, string[]> {\n  const /** @type {?} */ map = new Map<string, string[]>();\n  if (rawParams.length > 0) {\n    const /** @type {?} */ params: string[] = rawParams.split('&');\n    params.forEach((param: string) => {\n      const /** @type {?} */ eqIdx = param.indexOf('=');\n      const [key, val]: string[] =\n          eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)];\n      const /** @type {?} */ list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\n/**\n * \\@experimental \n * \n */\nexport class HttpQueryEncoder {\n/**\n * @param {?} k\n * @return {?}\n */\nencodeKey(k: string): string { return standardEncoding(k); }\n/**\n * @param {?} v\n * @return {?}\n */\nencodeValue(v: string): string { return standardEncoding(v); }\n}\n/**\n * @param {?} v\n * @return {?}\n */\nfunction standardEncoding(v: string): string {\n  return encodeURIComponent(v)\n      .replace(/%40/gi, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/gi, '$')\n      .replace(/%2C/gi, ',')\n      .replace(/%3B/gi, ';')\n      .replace(/%2B/gi, '+')\n      .replace(/%3D/gi, '=')\n      .replace(/%3F/gi, '?')\n      .replace(/%2F/gi, '/');\n}\n/**\n * Map-like representation of url search parameters, based on\n * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,\n * with several extensions for merging URLSearchParams objects:\n *   - setAll()\n *   - appendAll()\n *   - replaceAll()\n * \n * This class accepts an optional second parameter of ${\\@link ɵHttpQueryEncoder},\n * which is used to serialize parameters before making a request. By default,\n * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,\n * and then un-encodes certain characters that are allowed to be part of the query\n * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.\n * \n * These are the characters that are not encoded: `! $ \\' ( ) * + , ; A 9 - . _ ~ ? /`\n * \n * If the set of allowed query characters is not acceptable for a particular backend,\n * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.\n * \n * ```\n * import {URLSearchParams, QueryEncoder} from '\\@angular/http';\n * class MyQueryEncoder extends QueryEncoder {\n *   encodeKey(k: string): string {\n *     return myEncodingFunction(k);\n *   }\n * \n *   encodeValue(v: string): string {\n *     return myEncodingFunction(v);\n *   }\n * }\n * \n * let params = new URLSearchParams('', new MyQueryEncoder());\n * ```\n * \\@experimental\n */\nexport class HttpUrlParams {\n  paramsMap: Map<string, string[]>;\n/**\n * @param {?=} rawParams\n * @param {?=} queryEncoder\n */\nconstructor(public rawParams: string = '',\nprivate queryEncoder = /** @type {?} */(( new HttpQueryEncoder() as any))) {\n    this.paramsMap = paramParser(rawParams);\n  }\n/**\n * @return {?}\n */\nclone(): HttpUrlParams {\n    const /** @type {?} */ clone = new HttpUrlParams('', this.queryEncoder);\n    clone.appendAll(this);\n    return clone;\n  }\n/**\n * @param {?} param\n * @return {?}\n */\nhas(param: string): boolean { return this.paramsMap.has(param); }\n/**\n * @param {?} param\n * @return {?}\n */\nget(param: string): string|null {\n    const /** @type {?} */ storedParam = this.paramsMap.get(param);\n\n    return Array.isArray(storedParam) ? storedParam[0] : null;\n  }\n/**\n * @param {?} param\n * @return {?}\n */\ngetAll(param: string): string[] { return this.paramsMap.get(param) || []; }\n/**\n * @param {?} param\n * @param {?} val\n * @return {?}\n */\nset(param: string, val: string) {\n    if (val === void 0 || val === null) {\n      this.delete(param);\n      return;\n    }\n    const /** @type {?} */ list = this.paramsMap.get(param) || [];\n    list.length = 0;\n    list.push(val);\n    this.paramsMap.set(param, list);\n  }\n/**\n * @param {?} searchParams\n * @return {?}\n */\nsetAll(searchParams: HttpUrlParams) {\n    searchParams.paramsMap.forEach((value, param) => {\n      const /** @type {?} */ list = this.paramsMap.get(param) || [];\n      list.length = 0;\n      list.push(value[0]);\n      this.paramsMap.set(param, list);\n    });\n  }\n/**\n * @param {?} param\n * @param {?} val\n * @return {?}\n */\nappend(param: string, val: string): void {\n    if (val === void 0 || val === null) return;\n    const /** @type {?} */ list = this.paramsMap.get(param) || [];\n    list.push(val);\n    this.paramsMap.set(param, list);\n  }\n/**\n * @param {?} searchParams\n * @return {?}\n */\nappendAll(searchParams: HttpUrlParams) {\n    searchParams.paramsMap.forEach((value, param) => {\n      const /** @type {?} */ list = this.paramsMap.get(param) || [];\n      for (let /** @type {?} */ i = 0; i < value.length; ++i) {\n        list.push(value[i]);\n      }\n      this.paramsMap.set(param, list);\n    });\n  }\n/**\n * @param {?} searchParams\n * @return {?}\n */\nreplaceAll(searchParams: HttpUrlParams) {\n    searchParams.paramsMap.forEach((value, param) => {\n      const /** @type {?} */ list = this.paramsMap.get(param) || [];\n      list.length = 0;\n      for (let /** @type {?} */ i = 0; i < value.length; ++i) {\n        list.push(value[i]);\n      }\n      this.paramsMap.set(param, list);\n    });\n  }\n/**\n * @return {?}\n */\ntoString(): string {\n    const /** @type {?} */ paramsList: string[] = [];\n    this.paramsMap.forEach((values, k) => {\n      values.forEach(\n          v => paramsList.push(\n              this.queryEncoder.encodeKey(k) + '=' + this.queryEncoder.encodeValue(v)));\n    });\n    return paramsList.join('&');\n  }\n/**\n * @param {?} param\n * @return {?}\n */\ndelete (param: string): void { this.paramsMap.delete(param); }\n}\n\nfunction HttpUrlParams_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpUrlParams.prototype.paramsMap;\n/** @type {?} */\nHttpUrlParams.prototype.rawParams;\n/** @type {?} */\nHttpUrlParams.prototype.queryEncoder;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Inject, NgModule, Optional} from '@angular/core';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpClient} from './client';\nimport {HTTP_INTERCEPTORS, HttpInterceptor, HttpInterceptorHandler} from './interceptor';\nimport {JSONP_HOME, JsonpCallbackMap, JsonpClientBackend, JsonpInterceptor} from './jsonp';\nimport {BrowserXhr, HttpXhrBackend, XhrFactory} from './xhr';\n/**\n * Constructs a {\\@link HttpHandler} that applies a bunch of {\\@link HttpInterceptor}s\n * to a request before passing it to the given {\\@link HttpBackend}.\n * \n * Meant to be used as a factory function within {\\@link HttpClientModule}.\n * \n * \\@experimental\n * @param {?} backend\n * @param {?=} interceptors\n * @return {?}\n */\nexport function interceptingHandler(\n    backend: HttpBackend, interceptors: HttpInterceptor[] | null = []): HttpHandler {\n  if (!interceptors) {\n    return backend;\n  }\n  return interceptors.reduceRight(\n      (next, interceptor) => new HttpInterceptorHandler(next, interceptor), backend);\n}\n/**\n * Factory function that determines where to store JSONP callbacks.\n * \n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n * \n * \\@experimental\n * @return {?}\n */\nexport function jsonpCallbackMap(): Object {\n  let /** @type {?} */ _global: {[key: string]: any};\n  if (typeof window === 'object') {\n    return window;\n  }\n  return {};\n}\n/**\n * {\\@link NgModule} which provides the {\\@link HttpClient} and associated services.\n * \n * Interceptors can be added to the chain behind {\\@link HttpClient} by binding them\n * to the multiprovider for {\\@link HTTP_INTERCEPTORS}.\n * \n * \\@experimental\n */\nexport class HttpClientModule {\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  providers: [\n    HttpClient,\n    // HttpHandler is the backend + interceptors and is constructed\n    // using the interceptingHandler factory function.\n    {\n      provide: HttpHandler,\n      useFactory: interceptingHandler,\n      deps: [HttpBackend, [new Optional(), new Inject(HTTP_INTERCEPTORS)]],\n    },\n    HttpXhrBackend,\n    {provide: HttpBackend, useExisting: HttpXhrBackend},\n    BrowserXhr,\n    {provide: XhrFactory, useExisting: BrowserXhr},\n  ],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction HttpClientModule_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClientModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClientModule.ctorParameters;\n}\n\n/**\n * {\\@link NgModule} which enables JSONP support in {\\@link HttpClient}.\n * \n * Without this module, {\\@link HttpClient#jsonp} requests will reach the backend\n * with method JSONP, where they'll be rejected.\n * \n * \\@experimental\n */\nexport class HttpClientJsonpModule {\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  providers: [\n    JsonpClientBackend,\n    {provide: JsonpCallbackMap, useFactory: jsonpCallbackMap},\n    {provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true},\n  ],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction HttpClientJsonpModule_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClientJsonpModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClientJsonpModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpMethod, HttpRequest, HttpResponseType} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpResponseInit, HttpUploadProgressEvent} from './response';\n\nconst /** @type {?} */ XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n * @param {?} xhr\n * @return {?}\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class XhrFactory {\n/**\n * @abstract\n * @return {?}\n */\nbuild() {} }\n/**\n * A factory for \\@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n * \n * \\@experimental\n */\nexport class BrowserXhr implements XhrFactory {\nconstructor() {}\n/**\n * @return {?}\n */\nbuild(): any { return /** @type {?} */(( <any>(new XMLHttpRequest()))); }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction BrowserXhr_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserXhr.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserXhr.ctorParameters;\n}\n\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n/**\n * An {\\@link HttpBackend} which uses the XMLHttpRequest API to send\n * requests to a backend server.\n * \n * \\@experimental\n */\nexport class HttpXhrBackend implements HttpBackend {\n/**\n * @param {?} xhrFactory\n */\nconstructor(private xhrFactory: XhrFactory) {}\n/**\n * Process a request and return a stream of response events.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const /** @type {?} */ xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.url);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((values, name) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const /** @type {?} */ detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        xhr.responseType = /** @type {?} */(( req.responseType.toLowerCase() as any));\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const /** @type {?} */ reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let /** @type {?} */ headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const /** @type {?} */ partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const /** @type {?} */ status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const /** @type {?} */ statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const /** @type {?} */ headers = HttpHeaders.fromResponseHeaderString(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const /** @type {?} */ url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const /** @type {?} */ onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let /** @type {?} */ body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n\n          // Strip a common XSSI prefix from string responses.\n          // TODO: determine if this behavior should be optional and moved to an interceptor.\n          if (typeof body === 'string') {\n            body = body.replace(XSSI_PREFIX, '');\n          }\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let /** @type {?} */ ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (ok && typeof body === 'string' && req.responseType === 'json') {\n          // Attempt the parse. If it fails, a parse error should be delivered to the user.\n          try {\n            body = JSON.parse(body);\n          } catch ( /** @type {?} */error) {\n            // Even though the response status was 2xx, this is still an error.\n            ok = false;\n            // The parse error contains the text of the body that failed to parse.\n            body = /** @type {?} */(( { error, text: body } as HttpJsonParseError));\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const /** @type {?} */ onError = (error: ErrorEvent) => {\n        const /** @type {?} */ res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let /** @type {?} */ sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let /** @type {?} */ progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onUpProgress =\n          (event: ProgressEvent) => {\n            // Upload progress events are simpler. Begin building the progress\n            // event.\n            let /** @type {?} */ progress: HttpUploadProgressEvent = {\n              type: HttpEventType.UploadProgress,\n              loaded: event.loaded,\n            };\n\n            // If the total number of bytes being uploaded is available, include\n            // it.\n            if (event.lengthComputable) {\n              progress.total = event.total;\n            }\n\n            // Send the event.\n            observer.next(progress);\n          }\n\n                                    // By default, register for load and error events.\n                                    xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: XhrFactory, },\n];\n}\n\nfunction HttpXhrBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXhrBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXhrBackend.ctorParameters;\n/** @type {?} */\nHttpXhrBackend.prototype.xhrFactory;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Inject, Injectable, InjectionToken} from '@angular/core';\nimport {DOCUMENT} from '@angular/platform-browser';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpInterceptor} from './interceptor';\nimport {HttpMethod, HttpRequest, HttpResponseType} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet /** @type {?} */ nextRequestId: number = 0;\n\n// All callbacks are namespaced to this property on `window`.\nexport const /** @type {?} */ JSONP_HOME = '__ng__jsonp__';\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const /** @type {?} */ JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const /** @type {?} */ JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const /** @type {?} */ JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n * \n * In the browser, this should always be the `window` object.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class JsonpCallbackMap { [key: string]: (data: any) => void; }\n/**\n * {\\@link HttpBackend} that only processes {\\@link HttpRequest} with the JSONP method,\n * by performing JSONP style requests.\n * \n * \\@experimental\n */\nexport class JsonpClientBackend implements HttpBackend {\n/**\n * @param {?} callbackMap\n * @param {?} document\n */\nconstructor(private callbackMap: JsonpCallbackMap,\nprivate document: any) {}\n/**\n * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n * @return {?}\n */\nprivate nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n/**\n * Process a JSONP request and return an event stream of the results.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const /** @type {?} */ callback = this.nextCallback();\n      const /** @type {?} */ url = req.url.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const /** @type {?} */ node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let /** @type {?} */ body: any|null = null;\n\n      // Whether the response callback has been called.\n      let /** @type {?} */ finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let /** @type {?} */ cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const /** @type {?} */ cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const /** @type {?} */ onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the resposne is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const /** @type {?} */ onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: JsonpCallbackMap, },\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n];\n}\n\nfunction JsonpClientBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpClientBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpClientBackend.ctorParameters;\n/** @type {?} */\nJsonpClientBackend.prototype.callbackMap;\n/** @type {?} */\nJsonpClientBackend.prototype.document;\n}\n\n/**\n * An {\\@Link HttpInterceptor} which identifies requests with the method JSONP and\n * shifts them to the {\\@link JsonpClientBackend}.\n * \n * \\@experimental\n */\nexport class JsonpInterceptor {\n/**\n * @param {?} jsonp\n */\nconstructor(private jsonp: JsonpClientBackend) {}\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle( /** @type {?} */((req as HttpRequest<never>)));\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: JsonpClientBackend, },\n];\n}\n\nfunction JsonpInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpInterceptor.ctorParameters;\n/** @type {?} */\nJsonpInterceptor.prototype.jsonp;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\n\nimport {HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpEvent, HttpResponse} from './response';\n\n/**\n * Intercepts {@link HttpRequest}s and handles them.\n *\n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n *\n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n *\n * @experimental\n */\nexport interface HttpInterceptor {\n  /**\n   * Intercept an outgoing {@link HttpRequest} and optionally transform it or the\n   * response.\n   *\n   * Typically an interceptor will transform the outgoing request before returning\n   * `next.handle(transformedReq)`. An interceptor may choose to transform the\n   * response event stream as well, by applying additional Rx operators on the stream\n   * returned by `next.handle()`.\n   *\n   * More rarely, an interceptor may choose to completely handle the request itself,\n   * and compose a new event stream instead of invoking `next.handle()`. This is\n   * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n   *\n   * It is also rare but valid for an interceptor to return multiple responses on the\n   * event stream for a single request.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n/**\n * {\\@link HttpHandler} which applies an {\\@link HttpInterceptor} to an {\\@link HttpRequest}.\n * \n * \\@experimental\n */\nexport class HttpInterceptorHandler implements HttpHandler {\n/**\n * @param {?} next\n * @param {?} interceptor\n */\nconstructor(private next: HttpHandler,\nprivate interceptor: HttpInterceptor) {}\n/**\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return this.interceptor.intercept(req, this.next);\n  }\n}\n\nfunction HttpInterceptorHandler_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpInterceptorHandler.prototype.next;\n/** @type {?} */\nHttpInterceptorHandler.prototype.interceptor;\n}\n\n/**\n * A multi-provider token which represents the array of {\\@link HttpInterceptor}s that\n * are registered.\n * \n * \\@experimental\n */\nexport const HTTP_INTERCEPTORS = new InjectionToken<HttpInterceptor[]>('HTTP_INTERCEPTORS');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {of } from 'rxjs/observable/of';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {filter} from 'rxjs/operator/filter';\nimport {map} from 'rxjs/operator/map';\n\nimport {HttpHandler} from './backend';\nimport {HttpJsonpOptions, HttpMethodOptions, HttpObserve, HttpRequestOptions, zHttpMethodOptionsObserveArrayBufferBody, zHttpMethodOptionsObserveArrayBufferEvents, zHttpMethodOptionsObserveArrayBufferResponse, zHttpMethodOptionsObserveBlobBody, zHttpMethodOptionsObserveBlobEvents, zHttpMethodOptionsObserveBlobResponse, zHttpMethodOptionsObserveEvents, zHttpMethodOptionsObserveResponse, zHttpMethodOptionsObserveTextBody, zHttpMethodOptionsObserveTextEvents, zHttpMethodOptionsObserveTextResponse, zHttpRequestBodyOptions, zHttpRequestOptionsObserveArrayBufferBody, zHttpRequestOptionsObserveArrayBufferEvents, zHttpRequestOptionsObserveArrayBufferResponse, zHttpRequestOptionsObserveBlobBody, zHttpRequestOptionsObserveBlobEvents, zHttpRequestOptionsObserveBlobResponse, zHttpRequestOptionsObserveEvents, zHttpRequestOptionsObserveResponse, zHttpRequestOptionsObserveTextBody, zHttpRequestOptionsObserveTextEvents, zHttpRequestOptionsObserveTextResponse} from './client_types';\nimport {HttpHeaders} from './headers';\nimport {HttpMethod, HttpRequest, HttpResponseType} from './request';\nimport {HttpEvent, HttpEventType, HttpResponse} from './response';\nimport {HttpUrlParams} from './url_params';\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n * @template T\n * @param {?} options\n * @param {?} body\n * @return {?}\n */\nfunction addBody<T>(options: HttpMethodOptions, body: T | null): HttpRequestOptions<T> {\n  return {\n    body,\n    headers: options.headers,\n    observe: options.observe,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n  };\n}\n/**\n * The main API for making outgoing HTTP requests.\n * \n * \\@experimental\n */\nexport class HttpClient {\n/**\n * @param {?} handler\n */\nconstructor(private handler: HttpHandler) {}\n\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveArrayBufferBody<any>): Observable<ArrayBuffer>;\n  request(url: string, method: HttpMethod|string, options: zHttpRequestOptionsObserveBlobBody<any>):\n      Observable<Blob>;\n  request(url: string, method: HttpMethod|string, options: zHttpRequestOptionsObserveTextBody<any>):\n      Observable<string>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveArrayBufferEvents<any>):\n      Observable<HttpEvent<ArrayBuffer>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveBlobEvents<any>): Observable<HttpEvent<Blob>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveTextEvents<any>): Observable<HttpEvent<string>>;\n  request<R>(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveEvents<any>): Observable<HttpEvent<R>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveArrayBufferResponse<any>):\n      Observable<HttpResponse<ArrayBuffer>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveBlobResponse<any>): Observable<HttpResponse<Blob>>;\n  request(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveTextResponse<any>): Observable<HttpResponse<string>>;\n  request<R>(\n      url: string, method: HttpMethod|string,\n      options: zHttpRequestOptionsObserveResponse<any>): Observable<HttpResponse<R>>;\n  request(url: string, method: HttpMethod|string, options?: HttpRequestOptions<any>):\n      Observable<Object>;\n  request<R>(url: string, method: HttpMethod|string, options?: HttpRequestOptions<any>):\n      Observable<R>;\n/**\n * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n * fires the request through the chain of registered interceptors and on to the\n * server.\n * \n * This method can be called in one of two ways. Either a {\\@link HttpRequest}\n * instance can be passed directly as the only parameter, or a string URL can be\n * passed as the first parameter, a method optionally as the second, and an\n * options hash as the third.\n * \n * If a {\\@link HttpRequest} object is passed directly, an `Observable` of the\n * raw {\\@link HttpEvent} stream will be returned.\n * \n * If a request is instead built by providing a URL, the options object\n * determines the return type of `request()`. In addition to configuring\n * request parameters such as the outgoing headers and/or the body, the options\n * hash specifies two key pieces of information about the request: the\n * `responseType` and what to `observe`.\n * \n * The `responseType` value determines how a successful response body will be\n * parsed. If `responseType` is the default `json`, a type interface for the\n * resulting object may be passed as a type parameter to `request()`.\n * \n * The `observe` value determines the return type of `request()`, based on what\n * the consumer is interested in observing. A value of `events` will return an\n * `Observable<HttpEvent>` representing the raw {\\@link HttpEvent} stream,\n * including progress events by default. A value of `response` will return an\n * `Observable<HttpResponse<T>>` where the `T` parameter of `{\\@link HttpResponse}\n * depends on the `responseType` and any optionally provided type parameter.\n * A value of `body` will return an `Observable<T>` with the same `T` body type.\n * @param {?} first\n * @param {?=} method\n * @param {?=} options\n * @return {?}\n */\nrequest(\n      first: string|HttpRequest<any>, method?: HttpMethod|string,\n      options: HttpRequestOptions<any> = {}): Observable<any> {\n    let /** @type {?} */ req: HttpRequest<any>;\n    // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = /** @type {?} */(( first as HttpRequest<any>));\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming GET unless a method is\n      // provided.\n      req = new HttpRequest(first, /** @type {?} */(( method)), options.body || null, {\n        headers: options.headers,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const /** @type {?} */ events$: Observable<HttpEvent<any>> =\n        concatMap.call(of (req), (req: HttpRequest<any>) => this.handler.handle(req));\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const /** @type {?} */ res$: Observable<HttpResponse<any>> =\n        filter.call(events$, (event: HttpEvent<any>) => event instanceof HttpResponse);\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is an ArrayBuffer.\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new Error('Response is not an ArrayBuffer.');\n              }\n              return res.body;\n            });\n          case 'blob':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a Blob.\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new Error('Response is not a Blob.');\n              }\n              return res.body;\n            });\n          case 'text':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a string.\n              if (res.body !== null && typeof res.body !== 'string') {\n                throw new Error('Response is not a string.');\n              }\n              return res.body;\n            });\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return map.call(res$, (res: HttpResponse<any>) => res.body);\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n\n  delete (url: string, options: zHttpMethodOptionsObserveArrayBufferBody): Observable<ArrayBuffer>;\n  delete (url: string, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  delete (url: string, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  delete (url: string, options: zHttpMethodOptionsObserveArrayBufferEvents):\n      Observable<HttpEvent<ArrayBuffer>>;\n  delete (url: string, options: zHttpMethodOptionsObserveBlobEvents): Observable<HttpEvent<Blob>>;\n  delete (url: string, options: zHttpMethodOptionsObserveTextEvents): Observable<HttpEvent<string>>;\n  delete (url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<Object>>;\n  delete<T>(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<T>>;\n  delete (url: string, options: zHttpMethodOptionsObserveArrayBufferResponse):\n      Observable<HttpResponse<ArrayBuffer>>;\n  delete (url: string, options: zHttpMethodOptionsObserveBlobResponse):\n      Observable<HttpResponse<Blob>>;\n  delete (url: string, options: zHttpMethodOptionsObserveTextResponse):\n      Observable<HttpResponse<string>>;\n  delete (url: string, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<Object>>;\n  delete<T>(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<T>>;\n  delete (url: string, options?: HttpMethodOptions): Observable<Object>;\n  delete<T>(url: string, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * DELETE request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `delete()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\ndelete (url: string, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'DELETE', options);\n  }\n\n  get(url: string, options: zHttpMethodOptionsObserveArrayBufferBody): Observable<ArrayBuffer>;\n  get(url: string, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  get(url: string, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  get(url: string,\n      options: zHttpMethodOptionsObserveArrayBufferEvents): Observable<HttpEvent<ArrayBuffer>>;\n  get(url: string, options: zHttpMethodOptionsObserveBlobEvents): Observable<HttpEvent<Blob>>;\n  get(url: string, options: zHttpMethodOptionsObserveTextEvents): Observable<HttpEvent<string>>;\n  get(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<Object>>;\n  get<T>(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<T>>;\n  get(url: string,\n      options: zHttpMethodOptionsObserveArrayBufferResponse): Observable<HttpResponse<ArrayBuffer>>;\n  get(url: string, options: zHttpMethodOptionsObserveBlobResponse): Observable<HttpResponse<Blob>>;\n  get(url: string,\n      options: zHttpMethodOptionsObserveTextResponse): Observable<HttpResponse<string>>;\n  get(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<Object>>;\n  get<T>(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<T>>;\n  get(url: string, options?: HttpMethodOptions): Observable<Object>;\n  get<T>(url: string, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * GET request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `get()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nget(url: string, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'GET', options);\n  }\n\n  head(url: string, options: zHttpMethodOptionsObserveArrayBufferBody): Observable<ArrayBuffer>;\n  head(url: string, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  head(url: string, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  head(url: string, options: zHttpMethodOptionsObserveArrayBufferEvents):\n      Observable<HttpEvent<ArrayBuffer>>;\n  head(url: string, options: zHttpMethodOptionsObserveBlobEvents): Observable<HttpEvent<Blob>>;\n  head(url: string, options: zHttpMethodOptionsObserveTextEvents): Observable<HttpEvent<string>>;\n  head(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<Object>>;\n  head<T>(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<T>>;\n  head(url: string, options: zHttpMethodOptionsObserveArrayBufferResponse):\n      Observable<HttpResponse<ArrayBuffer>>;\n  head(url: string, options: zHttpMethodOptionsObserveBlobResponse): Observable<HttpResponse<Blob>>;\n  head(url: string, options: zHttpMethodOptionsObserveTextResponse):\n      Observable<HttpResponse<string>>;\n  head(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<Object>>;\n  head<T>(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<T>>;\n  head(url: string, options?: HttpMethodOptions): Observable<Object>;\n  head<T>(url: string, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * HEAD request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `head()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nhead(url: string, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'HEAD', options);\n  }\n\n  jsonp(url: string): Observable<any>;\n  jsonp<T>(url: string): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause a request\n * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n * \n * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n * If no such interceptor is reached, then the `JSONP` request will likely be\n * rejected by the configured backend.\n * @template T\n * @param {?} url\n * @return {?}\n */\njsonp<T>(url: string): Observable<T> {\n    return this.request<any>(url, 'JSONP', {\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  options(url: string, options: zHttpMethodOptionsObserveArrayBufferBody): Observable<ArrayBuffer>;\n  options(url: string, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  options(url: string, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  options(url: string, options: zHttpMethodOptionsObserveArrayBufferEvents):\n      Observable<HttpEvent<ArrayBuffer>>;\n  options(url: string, options: zHttpMethodOptionsObserveBlobEvents): Observable<HttpEvent<Blob>>;\n  options(url: string, options: zHttpMethodOptionsObserveTextEvents): Observable<HttpEvent<string>>;\n  options(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<Object>>;\n  options<T>(url: string, options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<T>>;\n  options(url: string, options: zHttpMethodOptionsObserveArrayBufferResponse):\n      Observable<HttpResponse<ArrayBuffer>>;\n  options(url: string, options: zHttpMethodOptionsObserveBlobResponse):\n      Observable<HttpResponse<Blob>>;\n  options(url: string, options: zHttpMethodOptionsObserveTextResponse):\n      Observable<HttpResponse<string>>;\n  options(url: string, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<Object>>;\n  options<T>(url: string, options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<T>>;\n  options(url: string, options?: HttpMethodOptions): Observable<Object>;\n  options<T>(url: string, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * OPTIONS request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `options()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\noptions(url: string, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'OPTIONS', options);\n  }\n\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferBody):\n      Observable<ArrayBuffer>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveTextBody):\n      Observable<string>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferEvents):\n      Observable<HttpEvent<ArrayBuffer>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobEvents):\n      Observable<HttpEvent<Blob>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveTextEvents):\n      Observable<HttpEvent<string>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveEvents):\n      Observable<HttpEvent<Object>>;\n  patch<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveEvents):\n      Observable<HttpEvent<T>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferResponse):\n      Observable<HttpResponse<ArrayBuffer>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobResponse):\n      Observable<HttpResponse<Blob>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveTextResponse):\n      Observable<HttpResponse<string>>;\n  patch(url: string, body: any|null, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<Object>>;\n  patch<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<T>>;\n  patch(url: string, body: any|null, options?: HttpMethodOptions): Observable<Object>;\n  patch<T>(url: string, body: any|null, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * PATCH request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `patch()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npatch(url: string, body: any|null, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'PATCH', addBody(options, body));\n  }\n\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferBody):\n      Observable<ArrayBuffer>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferEvents):\n      Observable<HttpEvent<ArrayBuffer>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobEvents):\n      Observable<HttpEvent<Blob>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveTextEvents):\n      Observable<HttpEvent<string>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveEvents):\n      Observable<HttpEvent<Object>>;\n  post<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveEvents):\n      Observable<HttpEvent<T>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveArrayBufferResponse):\n      Observable<HttpResponse<ArrayBuffer>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobResponse):\n      Observable<HttpResponse<Blob>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveTextResponse):\n      Observable<HttpResponse<string>>;\n  post(url: string, body: any|null, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<Object>>;\n  post<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<T>>;\n  post(url: string, body: any|null, options?: HttpMethodOptions): Observable<Object>;\n  post<T>(url: string, body: any|null, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npost(url: string, body: any|null, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'POST', addBody(options, body));\n  }\n\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveArrayBufferBody): Observable<ArrayBuffer>;\n  put(url: string, body: any|null, options: zHttpMethodOptionsObserveBlobBody): Observable<Blob>;\n  put(url: string, body: any|null, options: zHttpMethodOptionsObserveTextBody): Observable<string>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveArrayBufferEvents): Observable<HttpEvent<ArrayBuffer>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveBlobEvents): Observable<HttpEvent<Blob>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveTextEvents): Observable<HttpEvent<string>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveEvents): Observable<HttpEvent<Object>>;\n  put<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveEvents):\n      Observable<HttpEvent<T>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveArrayBufferResponse): Observable<HttpResponse<ArrayBuffer>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveBlobResponse): Observable<HttpResponse<Blob>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveTextResponse): Observable<HttpResponse<string>>;\n  put(url: string, body: any|null,\n      options: zHttpMethodOptionsObserveResponse): Observable<HttpResponse<Object>>;\n  put<T>(url: string, body: any|null, options: zHttpMethodOptionsObserveResponse):\n      Observable<HttpResponse<T>>;\n  put(url: string, body: any|null, options?: HttpMethodOptions): Observable<Object>;\n  put<T>(url: string, body: any|null, options?: HttpMethodOptions): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See {\\@link HttpClient#request} for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\nput(url: string, body: any|null, options: HttpMethodOptions = {}): Observable<any> {\n    return this.request<any>(url, 'PUT', addBody(options, body));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: HttpHandler, },\n];\n}\n\nfunction HttpClient_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClient.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClient.ctorParameters;\n/** @type {?} */\nHttpClient.prototype.handler;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable} from 'rxjs/Observable';\nimport {empty} from 'rxjs/observable/empty';\n\nimport {HttpHeaders} from './headers';\nexport type HttpEventType = number;\nexport let HttpEventType: any = {};\nHttpEventType.Sent = 0;\nHttpEventType.UploadProgress = 1;\nHttpEventType.ResponseHeader = 2;\nHttpEventType.DownloadProgress = 3;\nHttpEventType.Response = 4;\nHttpEventType.User = 5;\nHttpEventType[HttpEventType.Sent] = \"Sent\";\nHttpEventType[HttpEventType.UploadProgress] = \"UploadProgress\";\nHttpEventType[HttpEventType.ResponseHeader] = \"ResponseHeader\";\nHttpEventType[HttpEventType.DownloadProgress] = \"DownloadProgress\";\nHttpEventType[HttpEventType.Response] = \"Response\";\nHttpEventType[HttpEventType.User] = \"User\";\n\n\n/**\n * Base interface for progress events.\n *\n * @experimental\n */\nexport interface HttpProgressEvent {\n  /**\n   * Progress event type is either upload or download.\n   */\n  type: HttpEventType.DownloadProgress|HttpEventType.UploadProgress;\n\n  /**\n   * Number of bytes uploaded or downloaded.\n   */\n  loaded: number;\n\n  /**\n   * Total number of bytes to upload or download. Depending on the request or\n   * response, this may not be computable and thus may not be present.\n   */\n  total?: number;\n}\n\n/**\n * A download progress event.\n *\n * @experimental\n */\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.DownloadProgress;\n\n  /**\n   * The partial response body as downloaded so far.\n   *\n   * Only present if the responseType was `text`.\n   */\n  partialText?: string;\n}\n\n/**\n * An upload progress event.\n *\n * @experimental\n */\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.UploadProgress;\n}\n\n/**\n * An event indicating that the request was sent to the server. Useful\n * when a request may be retried multiple times, to distinguish between\n * retries on the final event stream.\n *\n * @experimental\n */\nexport interface HttpSentEvent { type: HttpEventType.Sent; }\n\n/**\n * A user-defined event.\n *\n * Grouping all custom events under this type ensures they will be handled\n * and forwarded by all implementations of interceptors.\n *\n * @experimental\n */\nexport interface HttpUserEvent<T> { type: HttpEventType.User; }\n\n/**\n * An error that represents a failed attempt to JSON.parse text coming back\n * from the server.\n *\n * It bundles the Error object with the actual response body that failed to parse.\n *\n * @experimental\n */\nexport interface HttpJsonParseError { error: Error, text: string, }\n\n/**\n * Union type for all possible events on the response stream.\n *\n * Typed according to the expected type of the response.\n *\n * @experimental\n */\nexport type HttpEvent<T> =\n    HttpSentEvent | HttpHeaderResponse | HttpResponse<T>| HttpProgressEvent | HttpUserEvent<T>;\n\n/**\n * Initialization hash for only those fields of the response which are available\n * before the body downloads.\n *\n * @experimental\n */\nexport interface HttpResponseHeaderInit {\n  headers?: HttpHeaders;\n  status?: number;\n  statusText?: string;\n  url?: string;\n}\n\n/**\n * Initialization hash for the full response, including a typed body.\n *\n * @experimental\n */\nexport interface HttpResponseInit<T> extends HttpResponseHeaderInit { body?: T; }\n\n/**\n * Initialization hash for an error response, including an untyped error.\n *\n * @experimental\n */\nexport interface HttpErrorResponseInit extends HttpResponseHeaderInit { error?: any; }\n/**\n * Base class for both {\\@link HttpResponse} and {\\@link HttpHeaderResponse}.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpResponseBase {\n/**\n * All response headers.\n */\nreadonly headers: HttpHeaders;\n/**\n * Response status code.\n */\nreadonly status: number;\n/**\n * Textual description of response status code.\n * \n * Do not depend on this.\n */\nreadonly statusText: string;\n/**\n * URL of the resource retrieved, or null if not available.\n */\nreadonly url: string|null;\n/**\n * Whether the status code falls in the 2xx range.\n */\nreadonly ok: boolean;\n/**\n * Type of the response, narrowed to either the full response or the header.\n */\nreadonly type: HttpEventType.Response|HttpEventType.ResponseHeader;\n/**\n * Super-constructor for all responses.\n * \n * The single parameter accepted is an initialization hash. Any properties\n * of the response passed there will override the default values.\n * @param {?} init\n * @param {?=} defaultStatus\n * @param {?=} defaultStatusText\n */\nconstructor(\n      init: HttpResponseHeaderInit, defaultStatus: number = 200, defaultStatusText: string = 'OK') {\n    // If the hash has values passed, use them to initialize the response.\n    // Otherwise use the default values.\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== undefined ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n\n    // Cache the ok value to avoid defining a getter.\n    this.ok = this.status >= 200 && this.status < 300;\n\n    // Seal the headers so they can't be further mutated.\n    this.headers.seal();\n  }\n}\n\nfunction HttpResponseBase_tsickle_Closure_declarations() {\n/**\n * All response headers.\n * @type {?}\n */\nHttpResponseBase.prototype.headers;\n/**\n * Response status code.\n * @type {?}\n */\nHttpResponseBase.prototype.status;\n/**\n * Textual description of response status code.\n * \n * Do not depend on this.\n * @type {?}\n */\nHttpResponseBase.prototype.statusText;\n/**\n * URL of the resource retrieved, or null if not available.\n * @type {?}\n */\nHttpResponseBase.prototype.url;\n/**\n * Whether the status code falls in the 2xx range.\n * @type {?}\n */\nHttpResponseBase.prototype.ok;\n/**\n * Type of the response, narrowed to either the full response or the header.\n * @type {?}\n */\nHttpResponseBase.prototype.type;\n}\n\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n * \n * {\\@link HttpHeaderResponse} is a {\\@link HttpEvent} available on the response\n * event stream, only when progress events are requested.\n * \n * \\@experimental\n */\nexport class HttpHeaderResponse extends HttpResponseBase {\n/**\n * Create a new {\\@link HttpHeaderResponse} with the given parameters.\n * @param {?=} init\n */\nconstructor(init: HttpResponseHeaderInit = {}) { super(init); }\n\n  readonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\n/**\n * Copy this {\\@link HttpHeaderResponse}, overriding its contents with the\n * given parameter hash.\n * @param {?=} update\n * @return {?}\n */\nclone(update: HttpResponseHeaderInit = {}): HttpHeaderResponse {\n    // Perform a straightforward initialization of the new HttpHeaderResponse,\n    // overriding the current parameters with new ones if given.\n    return new HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    })\n  }\n}\n\nfunction HttpHeaderResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpHeaderResponse.prototype.type;\n}\n\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n * \n * {\\@link HttpResponse} is a {\\@link HttpEvent} available on the response event\n * stream.\n * \n * \\@experimental\n */\nexport class HttpResponse<T> extends HttpResponseBase {\n/**\n * The response body, or `null` if one was not returned.\n */\nreadonly body: T|null;\n/**\n * Construct a new {\\@link HttpResponse}.\n * @param {?=} init\n */\nconstructor(init: HttpResponseInit<T> = {}) {\n    super(init);\n    this.body = init.body || null;\n  }\n\n  readonly type: HttpEventType.Response = HttpEventType.Response;\n\n  clone(): HttpResponse<T>;\n  clone(update: HttpResponseHeaderInit): HttpResponse<T>;\n  clone<V>(update: HttpResponseInit<V>): HttpResponse<V>;\n/**\n * @param {?=} update\n * @return {?}\n */\nclone(update: HttpResponseInit<any> = {}): HttpResponse<any> {\n    return new HttpResponse<any>({\n      body: (update.body !== undefined) ? update.body : this.body,\n      headers: update.headers || this.headers.clone(),\n      status: (update.status !== undefined) ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\nfunction HttpResponse_tsickle_Closure_declarations() {\n/**\n * The response body, or `null` if one was not returned.\n * @type {?}\n */\nHttpResponse.prototype.body;\n/** @type {?} */\nHttpResponse.prototype.type;\n}\n\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n * \n * Any error returned on the {\\@link Observable} response stream will be\n * wrapped in an {\\@link HttpErrorResponse} to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n * \n * \\@experimental\n */\nexport class HttpErrorResponse extends HttpResponseBase implements Error {\n  readonly name = 'HttpErrorResponse';\n  readonly message: string;\n  readonly error: any|null;\n/**\n * Errors are never okay, even when the status code is in the 2xx success range.\n */\nreadonly ok = false;\n/**\n * @param {?} init\n */\nconstructor(init: HttpErrorResponseInit) {\n    // Initialize with a default status of 0 / Unknown Error.\n    super(init, 0, 'Unknown Error');\n\n    // If the response was successful, then this was a parse error. Otherwise, it was\n    // a protocol-level failure of some sort. Either the request failed in transit\n    // or the server returned an unsuccessful status code.\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n    } else {\n      this.message =\n          `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n    }\n    this.error = init.error || null;\n  }\n}\n\nfunction HttpErrorResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpErrorResponse.prototype.name;\n/** @type {?} */\nHttpErrorResponse.prototype.message;\n/** @type {?} */\nHttpErrorResponse.prototype.error;\n/**\n * Errors are never okay, even when the status code is in the 2xx success range.\n * @type {?}\n */\nHttpErrorResponse.prototype.ok;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {HttpHeaders} from './headers';\nimport {HttpUrlParams} from './url_params';\n\n/**\n * Represents an HTTP request body when serialized for the server.\n *\n * @experimental\n */\nexport type HttpSerializedBody = ArrayBuffer | Blob | FormData | string;\n\n/**\n * A subset of the allowed values for `XMLHttpRequest.responseType` supported by\n * {@link HttpClient}.\n *\n * @experimental\n */\nexport type HttpResponseType = 'arraybuffer' | 'blob' | 'json' | 'text';\n\n/**\n * A type capturing HTTP methods which don't take request bodies.\n *\n * @experimental\n */\nexport type HttpNoBodyMethod = 'DELETE' | 'GET' | 'HEAD' | 'JSONP' | 'OPTIONS';\n\n/**\n * A type capturing HTTP methods which do take request bodies.\n *\n * @experimental\n */\nexport type HttpBodyMethod = 'POST' | 'PUT' | 'PATCH';\n\n/**\n * A type representing all (known) HTTP methods.\n *\n * @experimental\n */\nexport type HttpMethod = HttpBodyMethod | HttpNoBodyMethod;\n\n/**\n * Construction interface for {@link HttpRequest}s.\n *\n * All values are optional and will override default values if provided.\n *\n * @experimental\n */\nexport interface HttpRequestInit {\n  headers?: HttpHeaders;\n  reportProgress?: boolean;\n  responseType?: HttpResponseType;\n  withCredentials?: boolean;\n}\n\n/**\n * Cloning interface for {@link HttpRequestClone}.\n *\n * All values are optional and will be cloned from the base request if not\n * provided.\n *\n * @experimental\n */\nexport interface HttpRequestClone<T> extends HttpRequestInit {\n  body?: T|null;\n  method?: HttpMethod|string;\n  url?: string;\n  setHeaders?: {[name: string]: string | string[]};\n}\n/**\n * Determine whether the given HTTP method may include a body.\n * @param {?} method\n * @return {?}\n */\nfunction mightHaveBody(method: string): boolean {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n * \n * In some execution environments ArrayBuffer is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n * \n * In some execution environments Blob is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n * \n * In some execution environments FormData is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * An outgoing HTTP request with an optional typed body.\n * \n * {\\@link HttpRequest} represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a {\\@link HttpRequest}, the {\\@link HttpRequest#clone}\n * method should be used.\n * \n * \\@experimental\n */\nexport class HttpRequest<T> {\n/**\n * The request body, or `null` if one isn't set.\n * \n * Bodies are not enforced to be immutable, as they can include a reference to any\n * user-defined data type. However, interceptors should take care to preserve\n * idempotence by treating them as such.\n */\nreadonly body: T|null = null;\n/**\n * Outgoing headers for this request.\n */\nreadonly headers: HttpHeaders;\n/**\n * Whether this request should be made in a way that exposes progress events.\n * \n * Progress events are expensive (change detection runs on each event) and so\n * they should only be requested if the consumer intends to monitor them.\n */\nreadonly reportProgress: boolean = false;\n/**\n * Whether this request should be sent with outgoing credentials (cookies).\n */\nreadonly withCredentials: boolean = false;\n/**\n * The expected response type of the server.\n * \n * This is used to parse the response appropriately before returning it to\n * the requestee.\n */\nreadonly responseType: HttpResponseType = 'json';\n/**\n * The outgoing HTTP request method.\n */\nreadonly method: string;\n/**\n * @param {?} url\n */\nconstructor(url: string);\n/**\n * @param {?} url\n * @param {?} method\n * @param {?=} init\n */\nconstructor(url: string, method: HttpNoBodyMethod, init?: HttpRequestInit);\n/**\n * @param {?} url\n * @param {?} method\n * @param {?} body\n * @param {?=} init\n */\nconstructor(url: string, method: HttpBodyMethod, body: T|null, init?: HttpRequestInit);\n/**\n * @param {?} url\n * @param {?} method\n * @param {?} body\n * @param {?=} init\n */\nconstructor(url: string, method: HttpMethod|string, body: T|null, init?: HttpRequestInit);\n/**\n * @param {?} url\n * @param {?=} method\n * @param {?=} third\n * @param {?=} fourth\n */\nconstructor(\npublic readonly url: string, method?: string, third?: T|HttpRequestInit|null,\n      fourth?: HttpRequestInit) {\n    // Assume GET unless otherwise specified, and normalize the request method.\n    this.method = (method || 'GET').toUpperCase();\n    // Next, need to figure out which argument holds the HttpRequestInit\n    // options, if any.\n    let options: HttpRequestInit|undefined;\n\n    // Check whether a body argument is expected. The only valid way to omit\n    // the body argument is to use a known no-body method like GET.\n    if (mightHaveBody(this.method) || !!fourth) {\n      // Body is the third argument, options are the fourth.\n      this.body = third as T || null;\n      options = fourth;\n    } else {\n      // No body required, options are the third argument. The body stays null.\n      options = third as HttpRequestInit;\n    }\n\n    // If options have been passed, interpret them.\n    if (options) {\n      // Normalize reportProgress and withCredentials.\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n\n      // Override default response type of 'json' if one is provided.\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n\n      // Override headers if they're provided.\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n    }\n\n    // If no headers have been passed in, construct a new HttpHeaders instance.\n    if (!this.headers) {\n      this.headers = new HttpHeaders();\n    }\n\n    // In any case, seal the headers so no changes are allowed.\n    this.headers.seal();\n  }\n/**\n * Transform the free-form body into a serialized format suitable for\n * transmission to the server.\n * @return {?}\n */\nserializeBody(): HttpSerializedBody|null {\n    // If no body is present, no need to serialize it.\n    if (this.body === null) {\n      return null;\n    }\n    // Check whether the body is already in a serialized form. If so,\n    // it can just be returned directly.\n    if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n        typeof this.body === 'string') {\n      return this.body;\n    }\n    // Check whether the body is an object or array, and serialize with JSON if so.\n    if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n        Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    // Fall back on toString() for everything else.\n    return ( /** @type {?} */((this.body as any))).toString();\n  }\n/**\n * Examine the body and attempt to infer an appropriate MIME type\n * for it.\n * \n * If no such type can be inferred, this method will return `null`.\n * @return {?}\n */\ndetectContentTypeHeader(): string|null {\n    // An empty body has no content type.\n    if (this.body === null) {\n      return null;\n    }\n    // FormData instances are URL encoded on the wire.\n    if (isFormData(this.body)) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    // Blobs usually have their own content type. If it doesn't, then\n    // no type can be inferred.\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    // Array buffers have unknown contents and thus no type can be inferred.\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    // Technically, strings could be a form of JSON data, but it's safe enough\n    // to assume they're plain strings.\n    if (typeof this.body === 'string') {\n      return 'text/plain';\n    }\n    // Arrays, objects, and numbers will be encoded as JSON.\n    if (typeof this.body === 'object' || typeof this.body === 'number' ||\n        Array.isArray(this.body)) {\n      return 'application/json';\n    }\n    // No type could be inferred.\n    return null;\n  }\n\n  clone(): HttpRequest<T>;\n  clone(update: HttpRequestInit): HttpRequest<T>;\n  clone<V>(update: HttpRequestClone<V>): HttpRequest<V>;\n/**\n * @param {?=} update\n * @return {?}\n */\nclone(update: HttpRequestClone<any> = {}): HttpRequest<any> {\n    // For method, url, and responseType, take the current value unless\n    // it is overridden in the update hash.\n    const /** @type {?} */ method = update.method || this.method;\n    const /** @type {?} */ url = update.url || this.url;\n    const /** @type {?} */ responseType = update.responseType || this.responseType;\n\n    // The body is somewhat special - a `null` value in update.body means\n    // whatever current body is present is being overridden with an empty\n    // body, whereas an `undefined` value in update.body implies no\n    // override.\n    const /** @type {?} */ body = (update.body !== undefined) ? update.body : this.body;\n\n    // Carefully handle the boolean options to differentiate between\n    // `false` and `undefined` in the update args.\n    const /** @type {?} */ withCredentials =\n        (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n    const /** @type {?} */ reportProgress =\n        (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n\n    // Headers may need to be cloned later if they're sealed, but being\n    // appended to.\n    let /** @type {?} */ headers = update.headers || this.headers;\n\n    // Check whether the caller has asked to add headers.\n    if (update.setHeaders !== undefined) {\n      // Adding extra headers. If the current headers are sealed, they need to\n      // be cloned to unseal them first.\n      if (headers.sealed) {\n        headers = headers.clone();\n      }\n\n      // Set every requested header.\n      Object.keys(update.setHeaders)\n          .forEach(header => headers.set(header, /** @type {?} */(( update.setHeaders))[header]));\n    }\n\n    // Finally, construct the new HttpRequest using the pieces from above.\n    return new HttpRequest(\n        url, method, body, {\n                               headers, reportProgress, responseType, withCredentials,\n                           });\n  }\n}\n\nfunction HttpRequest_tsickle_Closure_declarations() {\n/**\n * The request body, or `null` if one isn't set.\n * \n * Bodies are not enforced to be immutable, as they can include a reference to any\n * user-defined data type. However, interceptors should take care to preserve\n * idempotence by treating them as such.\n * @type {?}\n */\nHttpRequest.prototype.body;\n/**\n * Outgoing headers for this request.\n * @type {?}\n */\nHttpRequest.prototype.headers;\n/**\n * Whether this request should be made in a way that exposes progress events.\n * \n * Progress events are expensive (change detection runs on each event) and so\n * they should only be requested if the consumer intends to monitor them.\n * @type {?}\n */\nHttpRequest.prototype.reportProgress;\n/**\n * Whether this request should be sent with outgoing credentials (cookies).\n * @type {?}\n */\nHttpRequest.prototype.withCredentials;\n/**\n * The expected response type of the server.\n * \n * This is used to parse the response appropriately before returning it to\n * the requestee.\n * @type {?}\n */\nHttpRequest.prototype.responseType;\n/**\n * The outgoing HTTP request method.\n * @type {?}\n */\nHttpRequest.prototype.method;\n}\n\n","\n/**\n * \\@experimental\n */\nexport const HTTP_HEADERS_SEALED_ERR = 'Headers have been sealed and cannot be mutated.';\n/**\n * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as\n * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).\n * \n * The only known difference between this `Headers` implementation and the spec is the\n * lack of an `entries` method.\n * \n * ### Example\n * \n * ```\n * import {Headers} from '\\@angular/http';\n * \n * var firstHeaders = new Headers();\n * firstHeaders.append('Content-Type', 'image/jpeg');\n * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'\n * \n * // Create headers from Plain Old JavaScript Object\n * var secondHeaders = new Headers({\n *   'X-My-Custom-Header': 'Angular'\n * });\n * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'\n * \n * var thirdHeaders = new Headers(secondHeaders);\n * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'\n * ```\n * \n * \\@experimental\n */\nexport class HttpHeaders {\n/**\n * \\@internal header names are lower case\n */\n_headers: Map<string, string[]> = new Map();\n/**\n * \\@internal map lower case names to actual names\n */\n_normalizedNames: Map<string, string> = new Map();\nprivate _lazyInit: Function|null = null;\n/**\n * \\@internal\n */\nsealed: boolean = false;\n/**\n * @param {?=} headers\n */\nconstructor(headers?: HttpHeaders|{[name: string]: any}|null) {\n    if (!headers) {\n      return;\n    }\n\n    if (headers instanceof HttpHeaders) {\n      headers.forEach((values: string[], name: string) => {\n        values.forEach(value => this.append(name, value));\n      });\n      return;\n    }\n\n    Object.keys(headers).forEach((name: string) => {\n      const values: string[] = Array.isArray(headers[name]) ? headers[name] : [headers[name]];\n      this.delete(name);\n      values.forEach(value => this.append(name, value));\n    });\n  }\n/**\n * Returns a new Headers instance from the given DOMString of Response Headers\n * @param {?} headersString\n * @return {?}\n */\nstatic fromResponseHeaderString(headersString: string): HttpHeaders {\n    const /** @type {?} */ headers = new HttpHeaders();\n\n    headers._lazyInit = () => {\n      headersString.split('\\n').forEach(line => {\n        const /** @type {?} */ index = line.indexOf(':');\n        if (index > 0) {\n          const /** @type {?} */ name = line.slice(0, index);\n          const /** @type {?} */ value = line.slice(index + 1).trim();\n          headers.set(name, value);\n        }\n      });\n    };\n\n    return headers;\n  }\n/**\n * Appends a header to existing list of header values for a given header name.\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nappend(name: string, value: string): void {\n    this.ensureInitialized();\n    if (this.sealed) {\n      throw new Error(HTTP_HEADERS_SEALED_ERR);\n    }\n    const /** @type {?} */ values = this.getAll(name);\n\n    if (values === null) {\n      this.set(name, value);\n    } else {\n      values.push(value);\n    }\n  }\n/**\n * Deletes all header values for the given name.\n * @param {?} name\n * @return {?}\n */\ndelete (name: string): void {\n    this.ensureInitialized();\n    if (this.sealed) {\n      throw new Error(HTTP_HEADERS_SEALED_ERR);\n    }\n    const /** @type {?} */ lcName = name.toLowerCase();\n    this._normalizedNames.delete(lcName);\n    this._headers.delete(lcName);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nforEach(fn: (values: string[], name: string, headers: Map<string, string[]>) => void): void {\n    this.ensureInitialized();\n    this._headers.forEach(\n        (values, lcName) => fn(values, /** @type {?} */(( this._normalizedNames.get(lcName))), this._headers));\n  }\n/**\n * Returns first header that matches given name.\n * @param {?} name\n * @return {?}\n */\nget(name: string): string|null {\n    this.ensureInitialized();\n    const /** @type {?} */ values = this.getAll(name);\n\n    if (values === null) {\n      return null;\n    }\n\n    return values.length > 0 ? values[0] : null;\n  }\n/**\n * Checks for existence of header by given name.\n * @param {?} name\n * @return {?}\n */\nhas(name: string): boolean {\n    this.ensureInitialized();\n    return this._headers.has(name.toLowerCase());\n  }\n/**\n * Returns the names of the headers\n * @return {?}\n */\nkeys(): string[] {\n    this.ensureInitialized();\n    return Array.from(this._normalizedNames.values());\n  }\n/**\n * Sets or overrides header value for given name.\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nset(name: string, value: string|string[]): void {\n    this.ensureInitialized();\n    if (this.sealed) {\n      throw new Error(HTTP_HEADERS_SEALED_ERR);\n    }\n    if (Array.isArray(value)) {\n      if (value.length) {\n        this._headers.set(name.toLowerCase(), [value.join(',')]);\n      }\n    } else {\n      this._headers.set(name.toLowerCase(), [value]);\n    }\n    this.mayBeSetNormalizedName(name);\n  }\n/**\n * Returns values of all headers.\n * @return {?}\n */\nvalues(): string[][] {\n    this.ensureInitialized();\n    return Array.from(this._headers.values());\n  }\n/**\n * @return {?}\n */\ntoJSON(): {[name: string]: any} {\n    this.ensureInitialized();\n    const /** @type {?} */ serialized: {[name: string]: string[]} = {};\n\n    this._headers.forEach((values: string[], name: string) => {\n      const /** @type {?} */ split: string[] = [];\n      values.forEach(v => split.push(...v.split(',')));\n      serialized[ /** @type {?} */((this._normalizedNames.get(name)))] = split;\n    });\n\n    return serialized;\n  }\n/**\n * Returns list of header values for a given name.\n * @param {?} name\n * @return {?}\n */\ngetAll(name: string): string[]|null {\n    this.ensureInitialized();\n    return this.has(name) ? this._headers.get(name.toLowerCase()) || null : null;\n  }\n/**\n * This method is not implemented.\n * @return {?}\n */\nentries() { throw new Error('\"entries\" method is not implemented on ɵHttpHeaders class'); }\n/**\n * @return {?}\n */\nclone(): HttpHeaders {\n    const /** @type {?} */ clone = new HttpHeaders();\n    this.forEach((values, name) => { clone.set(name, values); });\n    return clone;\n  }\n/**\n * \\@internal\n * @return {?}\n */\nseal(): void { this.sealed = true; }\n/**\n * @param {?} name\n * @return {?}\n */\nprivate mayBeSetNormalizedName(name: string): void {\n    const /** @type {?} */ lcName = name.toLowerCase();\n\n    if (!this._normalizedNames.has(lcName)) {\n      this._normalizedNames.set(lcName, name);\n    }\n  }\n/**\n * @return {?}\n */\nprivate ensureInitialized(): void {\n    if (this._lazyInit !== null) {\n      // Set _lazyInit to null first, otherwise lazy initialization\n      // may attempt to call other HttpHeaders methods which will\n      // call ensureInitialized() again.\n      const /** @type {?} */ init = this._lazyInit;\n      this._lazyInit = null;\n      // At the same time, save the sealing state and unseal for the initialization.\n      const /** @type {?} */ sealed = this.sealed;\n      this.sealed = false;\n      init();\n      // Restore sealed state.\n      this.sealed = sealed;\n    }\n  }\n}\n\nfunction HttpHeaders_tsickle_Closure_declarations() {\n/**\n * \\@internal header names are lower case\n * @type {?}\n */\nHttpHeaders.prototype._headers;\n/**\n * \\@internal map lower case names to actual names\n * @type {?}\n */\nHttpHeaders.prototype._normalizedNames;\n/** @type {?} */\nHttpHeaders.prototype._lazyInit;\n/**\n * \\@internal\n * @type {?}\n */\nHttpHeaders.prototype.sealed;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable} from 'rxjs/Observable';\nimport {HttpRequest, HttpSerializedBody} from './request';\nimport {HttpEvent} from './response';\n/**\n * \\@experimental\n * @abstract\n */\nexport abstract class HttpHandler {\n/**\n * @abstract\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>) {}\n}\n/**\n * \\@experimental\n * @abstract\n */\nexport abstract class HttpBackend implements HttpHandler {\n/**\n * @abstract\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>) {}\n}\n"],"names":["map"],"mappings":"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"}